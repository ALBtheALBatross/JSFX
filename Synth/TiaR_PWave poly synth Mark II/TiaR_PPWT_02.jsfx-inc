//@noindex

desc:PPWT Pre Processed Wave Tables
/*
SAT Saturation
    a soft saturation.
    Ctl: input gain
WRP Wrapper
    when the input signal exceeds one, it folds back.
    Ctl: input gain
PHD Phase Distortion
    the phase is a power function of the input phase
    Ctl: power exponent (0.25 to 4)
PCH Pitch shifter (a la sync)
    the waveform is read faster and copied back to the wave form
    Ctl: pitch coefficient
XSN Mul by a sine wave
    Ctl: pitch coefficient for the modulating wave
XSQ Mul by a square wave
    Ctl: pitch coefficient for the modulating wave
SNH Sample N Hold
    Ctl: Sample period up to 1/5 of the wave length
RSI Reversed Sample and Interpolate
    Ctl: Sample period up to 1/5 of the wave length
QNT Quantify
    Ctl: Quantification step
PWM Pulse Width Modulation
    Ctl: Compare level
SWP Swap
    Ctl: Swap position
HWR Hard Wrapper
    Ctl: input gain
MLO Modulo
    Ctl: modulo length
PMM3 Phase Modulation as Modulator for a 3 cycle carrier
    Ctl: modulation index (depth)
PMM8 Phase Modulator as a Modulator to a 1 to 8 cycle carrier
    Ctl: carrier frequency
PMC3 Phase Modulation as a Carrier with a 3 cycle modulator
    Ctl: modulation index (depth)
PMC8 Phase Modulation as a Carrier with a 1 to 8 cycle modulator
    Ctl: modulator frequency
CMB Comb
    Ctl: phase offset
CHR Chorus
    Ctl: phase offsets
PCC Pitch & Chorus
    Ctl: phase offsets
FHP Fourier High Pass
    Ctl: Lower harmonic (1..16)
*/
@init
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT() (
  1;
);
function PPWT_param3(v0 v1 v2 m)(
  m *= 2;
  m < 1 ? v0 +  m      * (v1 - v0)
        : v1 + (m - 1) * (v2 - v1);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_reset(h) 
instance(t tt l)
local(i p dp)(
  i = 0;
  p = 0;
  dp = h * 2 * $pi / l;
  loop(l,
    t[i] = sin(p);
    tt[i] = 0;
    p += dp;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_reset(h1 h2) 
instance(t tt l)
local(i p1 dp1 p2 dp2)(
  i = 0;
  p1 = 0;
  dp1 = h1 * 2 * $pi / l;
  p2 = 0;
  dp2 = h2 * 2 * $pi / l;
  loop(l,
    t[i] = 0.707 * (sin(p1) + sin(p2));
    tt[i] = 0;
    p1 += dp1;
    p2 += dp2;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_init() 
instance(t tt l)
local(i)(
  ad === 0 ? ad = 1;
  l = 512;
  t = ad;  ad += l;
  tt = ad;  ad += l; //work table
  this.PPWT_reset(1);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_copyToTT()
instance(t tt l)(
  memcpy(tt, t, l);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_interp(t l x)
local(x0 x1 a)(
  x = x + 128 * l;
  x0 = x|0;
  a = x - x0;
  x1 = x0 + 1;
  x0 %= l;
  x1 %= l;
  t[x0] + a * (t[x1] - t[x0]);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_norm(t l)
local(moy maxi i)
(
  moy = 0;
  i = 0;
  loop(l,
    moy += t[i];
    i += 1;
  );
  moy /= l;
  
  maxi = 0.001; //gain max = 1000;
  i = 0;
  loop(l,
    t[i] -= moy;
    maxi = max(maxi, abs(t[i]));
    i += 1;
  );
  
  maxi = 1 / maxi;
  i = 0;
  loop(l,
    t[i] *= maxi;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_normRMS(t l)
local(moy rms i)
(
  moy = 0;
  i = 0;
  loop(l,
    moy += t[i];
    i += 1;
  );
  moy /= l;
  
  rms = 0; //gain max = 1000;
  i = 0;
  loop(l,
    t[i] -= moy;
    rms += t[i] * t[i];
    i += 1;
  );
  rms = (rms/l)^0.5;
  rms = max(0.001, rms);
  rms = 0.707 / rms;
  i = 0;
  loop(l,
    t[i] *= rms;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_norm()
(
  PPWT_norm(this.t, this.l);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_normRMS()
(
  PPWT_normRMS(this.t, this.l);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_f_x3()
instance(t l)
local(i) (
  i = 0;
  loop(l,
    t[i] = t[i] * t[i] * t[i];
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Phase Modulation WT as Modulator
function PPWT_PMM(harmo index)
instance(t tt l)
local(i p dp e de xf) (
  xf = 0.5;
  index *= 16 * $pi * 0.5; // [0 1] normalized index
  this.PPWT_copyToTT();
  i = 0;
  p = 0;
  dp = 2 * $pi * harmo / l;
  loop(l,
    t[i] = sin(p + index * tt[i]);
    p += dp;
    i += 1;
  );
  xf *= l;
  xf > 1 ? (
    i = 0;
    e = 1;
    de = -1 / xf;
    loop(xf,
      t[i] += e * (sin(p + index * tt[i]) - t[i]);
      p += dp;
      e += de;
      i += 1;
    );
  );
);


// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Phase Modulation WT as Carrier
function PPWT_PMC(harmo index)
instance(t tt l)
local(i p dp xf e de) (
  xf = 0.5;
  index *= 16 * l; // [0 1] Normalized index 
  this.PPWT_copyToTT();
  i = 0;
  p = 0;
  dp = 2 * $pi * harmo / l;
  loop(l,
    t[i] = PPWT_interp(tt, l, i + index * sin(p));
    p += dp;
    i += 1;
  );
  xf *= l;
  xf > 1 ? (
    i = 0;
    e = 1;
    de = -1 / xf;
    loop(xf,
      t[i] += e * (PPWT_interp(tt, l, i + index * sin(p)) - t[i]);
      p += dp;
      e += de;
      i += 1;
    );
  );
);


// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Modulo
function PPWT_MLO(m)
instance(t tt l)
local(i p dp) (
  // [0 1] Normalized
  // 0 => modulo l => no effect
  // 0.5 => repeats twice the first half
  m = (1 - 0.9*m) * l; 
  this.PPWT_copyToTT();
  i = 0;
  p = 0;
  loop(l,
    t[i] = tt[(p + 512 * l) % l];
    p += 1;
    p > m ? p -= m;
    i += 1;
  );
);


// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Comb
function PPWT_CMB(d)
instance(t tt l)
local(i p) (
  this.PPWT_copyToTT();
  i = 0;
  p = d * 0.5 * l;
  loop(l,
    t[i] += tt[(p + 512 * l) % l];
    p += 1;
    i += 1;
  );
);

// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Chorus
function PPWT_CHR(d)
instance(t tt l)
local(i p1 p2 p3 ) (
  this.PPWT_copyToTT();
  i = 0;
  p1 = d * 0.5 * l + 0.4 * l;
  p2 = (d * d) * 0.8 * l + 0.4 * l;
  
  p3 = l - d*l*0.3;
  loop(l,
    t[i] -= tt[(p1 + 512 * l) % l];
    t[i] += tt[(p2 + 512 * l) % l];
    t[i] += tt[(p3 + 512 * l) % l];
    p1 += 1;
    p2 -= 1;
    p3 -= 1;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Pitch mul chorus
function PPWT_PCC(m)
instance(t tt l)
local(i m1 m2 m3) (
  // [0 1] -> [1 8]
  m1 = 1 + 5 * m; 
  m2 = 1 + 4 * m; 
  m3 = 1 + 7 * m * m; 
  this.PPWT_copyToTT();
  i = 0;
  loop(l,
    t[i] = PPWT_interp(tt, l, i * m1); //tt[(i * m1) % l];
    t[i] -= m * PPWT_interp(tt, l, i * m2 + 0.3 * l);//m * tt[(i * m2 + 0.3 * l) % l];
    t[i] += PPWT_interp(tt, l, i * m3); //tt[(i * m3) % l];
    i += 1;
  );
);


// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_SAT(coef)
instance(t l)
local(i) (
  i = 0;
  loop(l,
    t[i] = min(1, max(-1, t[i] * coef));
    t[i] = t[i] * (1.5 - 0.5 * t[i] * t[i]);
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_WRP(coef)
instance(t l)
local(x i) (
  i = 0;
  loop(l,
    x = t[i] * coef + 1 + 4 * 128;
    x = x - 4 * floor(x * 0.25);
    x > 2 ? x = 4 - x;
    t[i] = x - 1;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_WRPo(coef)
instance(t l)
local(i) (
  i = 0;
  loop(l,
    t[i] = sin(0.5 * $pi * t[i] * coef);
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_XSN(h)
instance(t l)
local(i v dv) (
  i = l - 1;
  v = 0;
  dv = 2 * $pi * h / l;
  loop(l,
    t[i] *= sin(v);
    i -= 1;
    v += dv;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_LPF(coef)
instance(t l)
local(i v) (
  loop(2,
    i = 0;
    loop(l,
      v += coef * (t[i] - v);
      i += 1;
    );
  );
  i = 0;
  loop(l,
    v += coef * (t[i] - v);
    t[i] = v;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_LPFB(coef)
instance(t l)
local(i v) (
  loop(2,
    i = l - 1;
    loop(l,
      v += coef * (t[i] - v);
      i -= 1;
    );
  );
  i = l - 1;
  loop(l,
    v += coef * (t[i] - v);
    t[i] = v;
    i -= 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_HPF(coef)
instance(t tt l)
local(i v) (
  this.PPWT_copyToTT();
  this.PPWT_LPF(coef);
  this.PPWT_LPFB(coef);
  i = 0;
  loop(l,
    t[i] = tt[i] - t[i];
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/*function PPWT_SNH(m)
instance(t l)
local(i v) (
  m = (1 + m * 0.2 * l)|0;
  i = 0;
  loop(l,
    (i % m) === 0 ? v = t[i];
    t[i] = v;
    i += 1;
  );
);*/
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_QNT(step)
instance(t l)
local(i) (
  i = 0;
  loop(l,
    t[i] = (t[i] / step) | 0;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_PWM(level)
instance(t l)
local(i v) (
  i = 0;
  loop(l,
    t[i] >= level ? t[i] = 1 : t[i] = -1;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_SWP(pos len)
instance(t l)
local(i v) (
  i = 0;
  loop(len,
    v = t[i];
    t[i] = t[(i + pos) % l];
    t[(i + pos) % l] = v;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_PHD(coef)
instance(t tt l)
local(i a _l) (
  this.PPWT_copyToTT();  
  i = 0;
  _l = 1 / l;
  a = 0;
  loop(l,
    t[i] = PPWT_interp(tt, l, (a ^ coef) * l);
    i += 1;
    a += _l;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// FHP Fourier High Pass
function PPWT_FHP(m)
instance(t l)
local(h) (
  MAP_fft(t, l);
  m = 15 * m * m;
  h = 1;
  loop(m,
    MAP_mulH(h, 0);
    h += 1;
  );
  MAP_mulH(h, 1-(m-(m|0)));
  MAP_ifft_zeroing(t, l);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// SMooTh low pass filter 0 -9 db/oct after h5
function PPWT_SMT(m)
instance(t l)
local(h e) (
  e = - 1.5 * (1 - m);
  h = 6;
  MAP_fft(t, l);
  loop(l - 6,
    MAP_mulH(h, (h - 4) ^ e);
    h += 1;
  );
  MAP_ifft_zeroing(t, l);
);

// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// Hard Wrap
function PPWT_HWR(m)
instance(t l)
local(i y) (
  m = 1 + 7 * m * m;
  i = 0;
  loop(l,
    y = 0.5*m*t[i] + 1024.5;
    y -= y|0;
    t[i] = 2 * y - 1;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// mul by square
function PPWT_XSQ(m)
instance(t l)
local(i p dp) (
  m = 2^(m*4);
  p = -1;
  dp = 2 * m / l;
  i = 0;
  loop(l,
    t[i] *= (2 * (p > 0)) - 1;
    p += dp;
    p > 1 ? p -= 2;
    i += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// Reverse Sample and Interpolate
/*function PPWT_RSI(m)
instance(t l)
local(i y0 y1 y dy _m) (
  m = (1 + m * 0.2 * l)|0;
  _m = 1 / m;
  i = 0;
  loop(l,
    (i % m) === 0 ? ( 
      y0 = t[i];
      y1 = t[(i + m) % l];
      y = y1;
      dy = (y0 - y1) * _m;
    );
    t[i] = y;
    y += dy;
    i += 1;
  );
);*/
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                               MUL SAW
function PPWT_XSW(m)
instance(t l)
local (i p dp)(
  p = 0;
  dp = 2^((m*5)-1);
  dp = 2 * dp / l;
  i = l - 1;
  loop(l,
    t[i] *= p;
    p += dp;
    p > 1 ? p -= 2;
    i -= 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                               ADD SAW
function PPWT_ASW(m)
instance(t l)
local (i p dp e de)(
  p = 0;
  dp = 2^((m*6)-1);
  dp = 2 * dp / l;
  i = 0;
  e = 1;
  de = -8 / l;
  loop(l,
    t[i] += e * p;
    p -= dp;
    p < 1 ? p += 2;
    i += 1;
    i >= 0.875 * l ?
      e += de;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                               ADD SIN
function PPWT_ASN(m)
instance(t l)
local (i p dp e de)(
  p = 0;
  dp = 2^( (m * 6)-1 );
  dp = 2 * $pi * dp / l;
  i = 0;
  e = 1;
  de = -8 / l;
  loop(l,
    t[i] += e * sin(p);
    p += dp;
    p > $pi ? p -= 2 * $pi;
    i += 1;
    i >= 0.875 * l ?
      e += de;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                               ADD SQR
function PPWT_ASQ(m)
instance(t l)
local (i p dp e de)(
  p = 0;
  dp = 2^((m*6)-1);
  dp = 2 * $pi * dp / l;
  i = 0;
  e = 1;
  de = -8 / l;
  loop(l,
    t[i] += e * sign(p);
    p += dp;
    p > $pi ? p -= 2 * $pi;
    i += 1;
    i >= 0.875 * l ?
      e += de;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// PCH wrap & xfade
function PPWT_PCH(h xf)
instance(t tt l)
local(i p e de) (
  this.PPWT_copyToTT();
  p = 0;
  i = 0;
  loop(l,
    t[i] = PPWT_interp(tt, l, p);
    p += h;
    i += 1;
  );
  xf *= l;
  xf > 1 ? (
    i = 0;
    e = 1;
    de = -1 / xf;
    loop(xf,
      t[i] += e * (PPWT_interp(tt, l, p) - t[i]);
      p += h;
      e += de;
      i += 1;
    );
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_PCH(m)
  local(h xf)(
  h = 2^(m*4-1);
  xf = 0.2 * abs(h - floor(h + 0.5));
  this.PPWT_PCH(h, xf);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//Pitch mul
function PPWT_PCH_old(m)
instance(t tt l)
local(c) (
  // [0 1] -> [1 8]
  m = 1 + 7 * m; 
  this.PPWT_copyToTT();
  c = 0;
  loop(l,
    t[c] = PPWT_interp(tt, l, c * m);
    c += 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_modulo(x m)
local(y)(
  m <= 1/512 ?
    y=0
  : (
    y = x / m;
    y=(y - floor(y)) * m;
  );
  y;
);

// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
// rebrou = 0: normal
// rebrou = 1: s&h
// rebrou = 2: reverse
// rebrou = -1: speed up
function PPWT_SNHval(m rebrou p)
instance(tt l) (
  PPWT_interp(tt, l, l * ( p - rebrou * PPWT_modulo(p, 0.499 * m)));
);

function PPWT_SNH(m rebrou)
instance(t l tt)
local(i p _l _dl)(
  this.PPWT_copyToTT();
  _l = 1 / l;
  _dl = 0.33 / l;
  p = 0;
  i = 0;
  loop(l,
    t[i] = this.PPWT_SNHval(m, rebrou, p)
         + 2*PPWT_SNHval(m, rebrou, p + _dl)
         + 3*PPWT_SNHval(m, rebrou, p + 2 * _dl)
         + 4*PPWT_SNHval(m, rebrou, p + 3 * _dl)
         + 3*PPWT_SNHval(m, rebrou, p + 4 * _dl)
         + 2*PPWT_SNHval(m, rebrou, p + 5 * _dl)
         + PPWT_SNHval(m, rebrou, p + 6 * _dl);
    i += 1;
    p += _l;
  );
);

// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_SNH(m)(
  this.PPWT_SNH(m, 1);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_RSI(m)(
  this.PPWT_SNH(m, 2);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_RS2(m)(
  this.PPWT_SNH(m, 3);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//RBR rebrouss
// 0    ---
// 1/3  SNH
// 2/3  RSI
// 1    RS2
// variable cycle (1/4 .. 1/6) 
function PPWT_RBR(m)(
  this.PPWT_SNH(1 / (5 + sin(3*2 * $pi * m)), 3 * m);
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_SAWP(m)
instance(t l)
local(i x dx) (
  i = 0;
  x = 0;
  dx = 1 / l;
  x2 = 0;
  dx2 = 2 / l;
  loop(l,
    t[i] = x;
    t[i] += m * (-x2 - t[i]);
    i += 1;
    x += dx;
    x2 += dx2;
    x2 > 1 ? x2 -= 1;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_TRIP(m)
instance(t l)
local(i x dx y ex) (
  i = 0;
  x = 0;
  dx = 2 / l;
  ex = 0.25 + 0.75*m + m * m * 7;
  loop(l,
    x<1 ? y = x
        : y = 2 - x;
    t[i] = y ^ ex;
    i += 1;
    x += dx;
  );
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_f(fn m)(
  fn ===  1 ? this.PPWT_SAT(1 + 7 * m * m) :
  fn ===  2 ? this.PPWT_WRP(1 + 7 * m * m) :
  fn ===  3 ? this.PPWT_PHD(0.25 + 3.75 * m) :
  fn ===  4 ? this.PPWT_PCH(m) :
  
  fn ===  5 ? this.PPWT_ASN(m) :
  fn ===  6 ? this.PPWT_ASQ(m) :
  fn ===  7 ? this.PPWT_ASW(m) :
  
  fn ===  8 ? this.PPWT_XSN(2^(m*5-1)) :
  fn ===  9 ? this.PPWT_XSQ(m) :
  fn === 10 ? this.PPWT_XSW(m) :
  
  fn === 11 ? this.PPWT_SNH(m) :
  fn === 12 ? this.PPWT_RSI(m) :
  fn === 13 ? this.PPWT_RS2(m) :
  fn === 14 ? this.PPWT_RBR(m) :
  fn === 15 ? this.PPWT_QNT(0.01 + 0.5 * m * m) :
  
  fn === 16 ? this.PPWT_PWM(m) :
  fn === 17 ? this.PPWT_SWP(512-m*256, m*128) :
  fn === 18 ? this.PPWT_HWR(m) :
  fn === 19 ? this.PPWT_MLO(m) :
  
  fn === 20 ? this.PPWT_PMM(3, 2*m) :
  fn === 21 ? this.PPWT_PMM(m * 8, 0.5) :
  fn === 22 ? this.PPWT_PMC(3, m*0.2) :
  fn === 23 ? this.PPWT_PMC(m * 8, 0.025) :
  
  fn === 24 ? this.PPWT_CMB(m) :
  fn === 25 ? this.PPWT_CHR(m) :
  fn === 26 ? this.PPWT_PCC(m) :
  
  fn === 27 ? this.PPWT_FHP(m) :
  fn === 28 ? this.PPWT_SMT(m) ;
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_g(fn m)(
  fn ===  1 ? this.PPWT_SAT(1 + 7 * m * m) :
  fn ===  2 ? this.PPWT_WRP(1 + 7 * m * m) :
  fn ===  3 ? this.PPWT_PHD(0.25 + 3.75 * m) :
  fn ===  4 ? this.PPWT_PCH(m) :
  
  fn ===  5 ? this.PPWT_ASN(m) :
  fn ===  6 ? this.PPWT_ASQ(m) :
  fn ===  7 ? this.PPWT_ASW(m) :
  
  fn ===  8 ? this.PPWT_XSN(2^(m*5-1)) :
  fn ===  9 ? this.PPWT_XSQ(m) :
  fn === 10 ? this.PPWT_XSW(m) :
  
  fn === 11 ? this.PPWT_SNH(m) :
  fn === 12 ? this.PPWT_RSI(m) :
  fn === 13 ? this.PPWT_RS2(m) :
  fn === 14 ? this.PPWT_RBR(m) :
  fn === 15 ? this.PPWT_QNT(0.01 + 0.5 * m * m) :
  
  fn === 16 ? this.PPWT_PWM(m) :
  fn === 17 ? this.PPWT_SWP(512-m*256, m*128) :
  fn === 18 ? this.PPWT_HWR(m) :
  fn === 19 ? this.PPWT_MLO(m) :
  
  fn === 20 ? this.PPWT_PMM(3, 2*m) :
  fn === 21 ? this.PPWT_PMM(m * 8, 0.5) :
  fn === 22 ? this.PPWT_PMC(3, m*0.2) :
  fn === 23 ? this.PPWT_PMC(m * 8, 0.025) :
  
  fn === 24 ? this.PPWT_SAWP(m) :
  fn === 25 ? this.PPWT_TRIP(m) ;
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
function PPWT_draw(x y w h)
instance(t l)
local(i)(
  gfx_x = x;
  gfx_y = y + h * (0.5 - 0.5 * t[0]);
  i = 1;
  loop(l - 1,
    gfx_lineto(x + (i * w)/l, y + h * (0.5 - 0.5 * t[i])  );
    i += 1;
  );
);
