/*
  @description PWave poly synth Mark II
  @version 1.0
  @author T.Rochebois
  @changelog
    + Initial release
  @provides   
    PWT_02.RPL
    TiaR_ADSR_03.jsfx-inc
    TiaR_KB6_01.jsfx-inc
    TiaR_LFO_04.jsfx-inc
    TiaR_LIM_01.jsfx-inc
    TiaR_MAP_02.jsfx-inc
    TiaR_PPWT_02.jsfx-inc
    TiaR_SCP_01.jsfx-inc
    TiaR_VCT_PPWT_02.jsfx-inc 
*/


desc:TiaR PWave poly synth Mark II  Smashed.Transistors at gmail.com
/*
 Copyright 2015, Thierry Rochebois
 Smashed.Transistors at gmail.com
 All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:
  Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer. 

  Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution. 

  The name of Thierry Rochebois may not be used to endorse or promote
  products derived from this software without specific prior written
  permission. 

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/
//______________________________________________________________________
//                                                              Features

// bend       [-1 1[
// modWheel   [ 0 1[
// expression [ 0 1]
//______________________________________________________________________
//                                                                 USAGE
//______________________________________________________________________
//                                                                 Ideas


slider1:0<0,25,1{---,SAT - Saturation,WRP - Fold it,PHD - Phase Distortion,PCH - Pitch Shift & Sync,ASN - Add a Res Sine,ASQ - Add a Syncd Square,ASW - Add a Syncd Saw,XSN - Sine Ring Mod,XSQ - Square Ring Mod,XSW - Saw Ring Mod,SNH - Sample and Hold,RSI - Sample and Reverse,RS2 - Sample and Reverse,RBR - Sample and Reverse,QNT - Qunatize,PWM - Comparator,SWP - Swapper,HWR - Hard Wrapper,MLO - Modulo,PMM3 - Phase Mod as Modulator,PMM8 - Phase Mod as Modulator,PMC3 - Phase Mod as Carrier,PMC8 - Phase Mod as Carrier,SAWP - Saw To Double Saw,TRIP - Triangle to Pulse}>Generator ---- Type
slider2:1<0,1>Full
slider3:0<0,1>Zero

slider4:0<0,28,1{---,SAT - Saturation,WRP - Fold it,PHD - Phase Distortion,PCH - Pitch Shift & Sync,ASN - Add a Res Sine,ASQ - Add a Syncd Square,ASW - Add a Syncd Saw,XSN - Sine Ring Mod,XSQ - Square Ring Mod,XSW - Saw Ring Mod,SNH - Sample and Hold,RSI - Sample and Reverse,RS2 - Sample and Reverse,RBR - Sample and Reverse,QNT - Quantizer,PWM - Comparator,SWP - Swapper,HWR - Hard Wrapper,MLO - Modulo,PMM3 - Phase Mod as Modulator,PMM8 - Phase Mod as Modulator,PMC3 - Phase Mod as Carrier,PMC8 - Phase Mod as Carrier,CMB - Comb Filter,CHR - Sort of Chorus,PCC - Pitch and Chorus,FHP - High Pass Filter,SMT - Smoothing Filter}>Modifier ---- Type
slider5:1<0,1>Full
slider6:0.5<0,1>Half
slider7:0<0,1>Zero

slider8:0<0,28,1{---,SAT - Saturation,WRP - Fold it,PHD - Phase Distortion,PCH - Pitch Shift & Sync,ASN - Add a Res Sine,ASQ - Add a Syncd Square,ASW - Add a Syncd Saw,XSN - Sine Ring Mod,XSQ - Square Ring Mod,XSW - Saw Ring Mod,SNH - Sample and Hold,RSI - Sample and Reverse,RS2 - Sample and Reverse,RBR - Sample and Reverse,QNT - Quantizer,PWM - Comparator,SWP - Swapper,HWR - Hard Wrapper,MLO - Modulo,PMM3 - Phase Mod as Modulator,PMM8 - Phase Mod as Modulator,PMC3 - Phase Mod as Carrier,PMC8 - Phase Mod as Carrier,CMB - Comb Filter,CHR - Sort of Chorus,PCC - Pitch and Chorus,FHP - High Pass Filter,SMT - Smoothing Filter}>Modifier ---- Type
slider9:1<0,1>Full
slider10:0.5<0,1>Half
slider11:0<0,1>Zero

slider12:0<0,8,1{Env,Env + Wheel,Env + LFO2,LFO2,Env + LFOs,RND,Env + RND,Env x RND,Env + Aft}>Modifier mode

slider13:0<-60,0>Filter ---------- P1
slider14:-24<-60,0>P0
slider15:0<0,9,1{Env,Env+Wheel,Env+LFO2,LFO2,Env + Aft,KF Env,KF Env+Wheel,KF Env+LFO2,KF LFO2,KF Env + Aft}>Filter mode

slider16:0.001<0.001,10>Modifier Env ---- A
slider17:5<0.001,10>D
slider18:0.0<0,1>S
slider19:0.2<0.001,10>R

slider20:0.001<0.001,10>Filter Env ------- A
slider21:2<0.001,10>D
slider22:0.5<0,1>S
slider23:0.2<0.001,10>R

slider24:0.001<0.001,10>Out Env ----------- A
slider25:0.2<0.001,10>D
slider26:0.5<0,1>S
slider27:2<0.001,10>R
slider28:6<4,8>LFO ------- rate
slider29:10<0,100>depth
slider30:0.125<0.125,20>LFO2 ----- rate

slider31:0<-1,1>Sub osc --- gain
slider32:1<0,10>detune %
slider33:0<0,6,1{unisson,+8ve,-8ve,+5th,-5th,+4th,-4th}>transpose
slider34:0<0,4,1{Const,Aft,Wheel,Mod Env,Flt Env}>modulation

import TiaR_MAP_02.jsfx-inc
import TiaR_PPWT_02.jsfx-inc
//VCT implements VOX !
import TiaR_VCT_PPWT_02.jsfx-inc

import TiaR_KB6_01.jsfx-inc
import TiaR_LFO_04.jsfx-inc
import TiaR_LIM_01.jsfx-inc
import TiaR_SCP_01.jsfx-inc
//______________________________________________________________________
@init
init_phase = 1;
//_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                          Global init
ad = 1;     //base address for tables (increment it when allocating mem)
TUNING = 440.0;
KRATE = 16; // control every 16 samples
ONE_OVER_KRATE = 1.0 / KRATE;
k = KRATE; // control rate counter

//_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
SAMPLES_BLOCK_MAX = 2048;
out0 = ad; ad += SAMPLES_BLOCK_MAX;
out1 = ad; ad += SAMPLES_BLOCK_MAX;

//_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
MAP();
PPWT();
ppwt.PPWT_init();
map.MAP_init(ppwt.l, 32);
rebour = 20 * map.nb;
cpt = 128;
nt = 18;
no = map.nb - 1;

scp.SCP_init();
scp.r = 0; scp.g = 1; scp.b = 0.0;

// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
KB6();
LFO();
VOX();
LIM();
//_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
v1.VOX_init();
v2.VOX_init();
v3.VOX_init();
v4.VOX_init();
v5.VOX_init();
v6.VOX_init();
lim.LIM_init();

// Use and abuse of global variable to avoid passing them to the voice
// instances, they are directly used in VOX.
gDPCOEF = 1;

//______________________________________________________________________
function adaptKRATEtoSamplesblock() 
  local (i d) (
  KRATE = 1; //default value that always works
  i = 15;   //min desired value 16
  while(
    i += 1;
    d = samplesblock / i;
    d == d|0 ? KRATE = i;
    KRATE === 1 && i < samplesblock;
  );
  K_PER_SAMPLESBLOCK = (samplesblock / KRATE)|0;
  ONE_OVER_KRATE = 1.0 / KRATE;
);
//______________________________________________________________________
@slider

subOscRatio;
  slider33 === 0 ? subOscRatio = 1 :
  slider33 === 1 ? subOscRatio = 2 :
  slider33 === 2 ? subOscRatio = 0.5 :
  slider33 === 3 ? subOscRatio = 3/2 :
  slider33 === 4 ? subOscRatio = 2/3 :
  slider33 === 5 ? subOscRatio = 4/3 :
  slider33 === 6 ? subOscRatio = 3/4;

init_phase === 1 ?(
  init_phase = 0;
  init_sliders = 1;
);
//Activate the refresh cycle if necessary

   as1 !== slider1 || as2 !== slider2 || as3 !== slider3
|| as4 !== slider4 || as5 !== slider5 || as6 !== slider6
|| as7 !== slider7 || as8 !== slider8 || as9 !== slider9
|| as10 !== slider10 || as11 !== slider11 ?  rebour = 20 * map.nb;

as1 = slider1; as2 = slider2; as3 = slider3; as4 = slider4;
as5 = slider5; as6 = slider6; as7 = slider7; as8 = slider8;
as9 = slider9; as10 = slider10; as11 = slider11;
//______________________________________________________________________
@block
function update()(
    nt <= 17 ?
      (
        map.MAP_update(ppwt.t,nt,no);
        nt += 1;
      )
    : ( //every 3sec 
      nt = 0;
      no += 1;
      no >= map.nb ? no -= map.nb;
      a = no / (map.nb - 1);
      ppwt.PPWT_reset(1);   
      ppwt.PPWT_g(slider1, slider3 + a * (slider2 - slider3));
      ppwt.PPWT_norm();
      ppwt.PPWT_f(slider4, PPWT_param3(slider7, slider6, slider5, a));
      ppwt.PPWT_norm();
      ppwt.PPWT_f(slider8, PPWT_param3(slider11, slider10, slider9, a));
      ppwt.PPWT_normRMS();
    );
);
scp.SCP_sProc(0, 0.01);
//First time after init, we update everything
init_sliders === 1 ? (
  loop(rebour,
    update();
  );
  rebour == -1;
  init_sliders = 0;
);
rebour >= 0 && cpt >= 128 ? (
  cpt = 0;
  update();  rebour -= 1;
  update();  rebour -= 1;
  update();  rebour -= 1;
  update();  rebour -= 1;
  update();  rebour -= 1;
  update();  rebour -= 1;
);
// _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _


adaptKRATEtoSamplesblock();
//KB6_proc(1024,v1,v2,v3,v4,v5,v6);
//modWheel5perc = slider4 * modWheel;

memset(out0, 0, samplesblock);
memset(out1, 0, samplesblock);
sc = 0; //sample counter

loop(K_PER_SAMPLESBLOCK,
  KB6_proc(sc,v1,v2,v3,v4,v5,v6);

  v1.VOX_kProc();
  v2.VOX_kProc();
  v3.VOX_kProc();
  v4.VOX_kProc();
  v5.VOX_kProc();
  v6.VOX_kProc(); 
  KB6_kProc();
  // Attention, tout dans out0, modifier le code pour la stereo !
  slider31 == 0 ? (
    i = sc; v1.activity!== 0 ? loop(KRATE, out0[i] += v1.VOX_aProc(); i += 1; );
    i = sc; v2.activity!== 0 ? loop(KRATE, out0[i] += v2.VOX_aProc(); i += 1; );
    i = sc; v3.activity!== 0 ? loop(KRATE, out0[i] += v3.VOX_aProc(); i += 1; );
    i = sc; v4.activity!== 0 ? loop(KRATE, out0[i] += v4.VOX_aProc(); i += 1; );
    i = sc; v5.activity!== 0 ? loop(KRATE, out0[i] += v5.VOX_aProc(); i += 1; );
    i = sc; v6.activity!== 0 ? loop(KRATE, out0[i] += v6.VOX_aProc(); i += 1; );
  ) : (
    i = sc; v1.activity!== 0 ? loop(KRATE, out0[i] += v1.VOX_aProcChorus(); i += 1; );
    i = sc; v2.activity!== 0 ? loop(KRATE, out0[i] += v2.VOX_aProcChorus(); i += 1; );
    i = sc; v3.activity!== 0 ? loop(KRATE, out0[i] += v3.VOX_aProcChorus(); i += 1; );
    i = sc; v4.activity!== 0 ? loop(KRATE, out0[i] += v4.VOX_aProcChorus(); i += 1; );
    i = sc; v5.activity!== 0 ? loop(KRATE, out0[i] += v5.VOX_aProcChorus(); i += 1; );
    i = sc; v6.activity!== 0 ? loop(KRATE, out0[i] += v6.VOX_aProcChorus(); i += 1; );
  );
  sc += KRATE;
);
KB6_proc(sc,v1,v2,v3,v4,v5,v6); //what remains in the midi buffer
sc = 0; //resets the sample counter for the sample section

//______________________________________________________________________
@slider

time_coef = 2.71 / srate;
  
//output env
v1.adsr.ADSR_set(slider24, slider25, slider26, slider27);
v2.adsr.ADSR_set(slider24, slider25, slider26, slider27);
v3.adsr.ADSR_set(slider24, slider25, slider26, slider27);
v4.adsr.ADSR_set(slider24, slider25, slider26, slider27);
v5.adsr.ADSR_set(slider24, slider25, slider26, slider27);
v6.adsr.ADSR_set(slider24, slider25, slider26, slider27);

//modifiers env
v1.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);
v2.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);
v3.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);
v4.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);
v5.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);
v6.adsrMod.ADSR_set(slider16, slider17, slider18, slider19);

//filter env
v1.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);
v2.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);
v3.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);
v4.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);
v5.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);
v6.adsrFlt.ADSR_set(slider20, slider21, slider22, slider23);

//independant LFOs with slight period variations
v1.lfo1.LFO_setF(slider28);          v1.lfo2.LFO_setF(slider30);
v2.lfo1.LFO_setF(slider28 * 1.01);   v2.lfo2.LFO_setF(slider30 * 0.97);
v3.lfo1.LFO_setF(slider28 * 0.99);   v3.lfo2.LFO_setF(slider30 * 1.013);
v4.lfo1.LFO_setF(slider28 * 1.007);  v4.lfo2.LFO_setF(slider30 * 0.983);
v5.lfo1.LFO_setF(slider28 * 1.013);  v5.lfo2.LFO_setF(slider30 * 0.967);
v6.lfo1.LFO_setF(slider28 * 1.017);  v6.lfo2.LFO_setF(slider30 * 0.993);

//______________________________________________________________________
@gfx
w_3 = gfx_w*0.33333;
w2_3 = gfx_w*0.66667;
h_3 = gfx_h*0.33333;


gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = w2_3 + 2; gfx_y = 2;
gfx_drawstr("FULL");
gfx_x = w2_3 + 2; gfx_y = 2 + h_3;
gfx_drawstr("HALF");
gfx_x = w2_3 + 2; gfx_y = 2 + 2 * h_3;
gfx_drawstr("ZERO");

scp.SCP_gProcOneTrace(2, 0, w2_3 - 4, gfx_h);

rebour <= 0 ? ( gfx_r = 1;   gfx_g = 0.5; gfx_b = 0;  )
            : ( gfx_r = 0.3; gfx_g = 0.2; gfx_b = 0.1;);
map.MAP_draw(72, w2_3,     0, w_3-20, h_3, 31);
map.MAP_draw(72, w2_3,   h_3, w_3-20, h_3,  15);
map.MAP_draw(72, w2_3, 2*h_3, w_3-20, h_3,  0);

rebour > 0 ? (
  gfx_r = 1; gfx_g = 0; gfx_b = 0;
  gfx_x = w2_3 + 40; gfx_y = 2; 
  gfx_drawstr("UPDATE PENDING");
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = w2_3; gfx_y = 0; gfx_lineto(w2_3, gfx_h);
gfx_x = w2_3; gfx_y = h_3; gfx_lineto(gfx_w-20, h_3);
gfx_x = w2_3; gfx_y = 2*h_3; gfx_lineto(gfx_w-20, 2*h_3);
gfx_x = gfx_w-20; gfx_y = 0; gfx_lineto(gfx_w-20, gfx_h);
VOX_gActivities(gfx_w-18, 2, 16, 16*6);
//______________________________________________________________________
@sample
fexpression += 0.05 * (expression - fexpression);
//v = fexpression * lim.LIM_aProc( 0.5*out0[sc]);
v = fexpression * 0.5*out0[sc];
spl0 += v;
spl1 += v;
scp.SCP_aProcOneTrace(spl0);
sc += 1;
cpt += 1;
//_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
//                                                           Audio Rate








